// Original example with an extra role D who "encrypts" the secret number within a range 
// Implementable because the encryption is actually trivial 

Initial state: (0)
Initial register assignments: rn=0, rt=0, rx=0, rs=0
(0) a->d:n{rn'=n/\rt'=rt/\rx'=rx/\rs'=rs} (11)
(11) d->b:s{s=rn*12345/\rs'=s/\rn'=rn/\rt'=0/\rx'=rx} (12)
(12) a->b:t{t>0/\rn'=rn/\rt'=t/\rx=rx'/\rs'=rs} (2)
(2) c->b:x{rx'=x/\rn'=rn/\rt'=rt/\rs'=rs} (3)
(3) b->c:higher{higher=3/\rn>rx/\rt>1/\rn'=rn/\rt'=rt-1/\rx'=rx/\rs'=rs} (2)
(3) b->c:won{won=1/\rn=rx/\rn'=rn/\rt'=rt/\rx'=rx/\rs'=rs} (5)
(5) b->a:lost{lost=0/\rn'=rn/\rt'=rt/\rx'=rx/\rs'=rs} (7)
(3) b->c:lower{lower=2/\rn<rx/\rt>1/\rn'=rn/\rt'=rt-1/\rx'=rx/\rs'=rs} (2)
(3) b->c:lost{lost=0/\rn!=rx/\rt=1/\rn'=rn/\rt'=rt/\rx'=rx/\rs'=rs} (6)
(6) b->a:won{won=1/\rn'=rn/\rt'=rt/\rx'=rx/\rs'=rs} (7)
Final states: (7)
