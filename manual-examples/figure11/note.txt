This folder contains the protocol from Figure 11 of the OOPSLA paper:  
	p->q:x{True}. q->r:y{y>x}. r->p:z{z>x}. 0 

Formal translation of the protocol, replacing states with integers, giving names to the registers, including register preservation explicitly, and renaming all communication variables to v. 

States: {0,1,2,3}
Registers: {rx,ry}
Initial register assignment: rx=0, ry=0

   (0) p->q:v{rx'=v/\ry'=ry} (1)
   (1) q->r:v{ry'=v/\v>rx/\rx'=rx} (2)
   (2) r->p:v{v>rx/\rx'=rx/\ry'=ry} (3)

For protocol S, let S1 and S2 be the two identical copies of S. 

First, we define all the inductive predicates required:

/* Defining prodreach_p */ 
prodreach_p (s1:int) (rx1:int) (ry1:int) (s2:int) (rx2:int) (ry2:int): bool =mu 
/* Restricting the domain for states */ 
	(s1 = 0 \/ s1 = 1 \/ s1 = 2 \/ s1 = 3) 
/\
	(s2 = 0 \/ s2 = 1 \/ s2 = 2 \/ s2 = 3) 
/\ 
/* First disjunct: base case */ 
	(s1 = 0 /\ s2 = 0 /\ rx1 = 0 /\ ry1 = 0 /\ rx2 = 0 /\ ry2 = 0)
	\/ 
/* Second disjuncts: both copies take a step */ 
/* Enumerating pairs of states where both copies can take a simultaneous step */ 
	(s1 = 1 /\ s2 = 1 /\ 
	(exists (x1:int) (x2:int) (rx1_pre:int) (ry1_pre:int) (rx2_pre:int) (ry2_pre:int). 
	prodreach_p 0 rx1_pre ry1_pre 0 rx2_pre ry2_pre /\ 
	rx1 = x1 /\ ry1 = ry1_pre /\ 
	rx2 = x2 /\ ry2 = ry2_pre /\ 
	x1 = x2))
\/ 
	(s1 = 3 /\ s2 = 3 /\ 
	(exists (x1:int) (x2:int) (rx1_pre:int) (ry1_pre:int) (rx2_pre:int) (ry2_pre:int). 
	prodreach_p 2 rx1_pre ry1_pre 2 rx2_pre ry2_pre /\ 
	x1 > rx1 /\ rx1 = rx1_pre /\ ry1 = ry1_pre /\ 
	x2 > rx2_pre /\ rx2 = rx2_pre /\ ry2 = ry2_pre /\ 
	x1 = x2))
\/ 
/* Third disjuncts: first copy takes an epsilon step */ 
/* Enumerating states where the first copy takes an epsilon step:
- (0) p->q:v{rx'=v/\ry'=ry} (1) */ 
	(s1 = 2 /\ 
	(exists (x1:int) (rx1_pre:int) (ry1_pre:int). 
	prodreach_p 1 rx1_pre ry1_pre s2 rx2 ry2 /\ 
	ry1 = x1 /\ x1 > rx1_pre /\ rx1 = rx1_pre)) 
\/ 
/* Fourth disjuncts: second copy takes an epsilon step */ 
	(s2 = 2 /\ 
	(exists (x2:int) (rx2_pre:int) (ry2_pre:int). 
	prodreach_p s1 rx1 ry1 1 rx2_pre ry2_pre /\ 
	ry2 = x2 /\ x2 > rx2_pre /\ rx2 = rx2_pre));

/* Defining unreach_pq */
/* The inductive predicate is actually a disjunction of 4, one for each state */ 
/* Hence the outermost disjunct is a case analysis on s */ 
/* The inner conjuncts are for unreach from that particular state */ 

unreach_pq (s:int) (rx:int) (ry:int) (x:int): bool =nu
	(s = 0 
	/\ 
	(forall (rx':int) (ry':int). rx'=x/\ry'=ry => false))
\/ 
	(s = 1 /\ 
	(forall (y:int) (rx':int) (ry':int). ry'=y/\y>rx/\rx'=rx => unreach_pq 2 rx' ry' x))
\/ 
	(s = 2 /\ 
	(forall (y:int) (rx':int) (ry':int). y>rx/\ry'=ry => unreach_pq 3 rx' ry' x));

/* Defining avail */ 

Symbolic Send Coherence for participant p quantifies over all transitions in S1 in which p is the sender, and over all states in S2. 
Thus, Symbolic Send Coherence for p for this protocol enumerates the following pairs of states and transitions: 
- (0) p->q:v{rx'=v/\ry'=ry} (1), (0)
- (0) p->q:v{rx'=v/\ry'=ry} (1), (1)
- (0) p->q:v{rx'=v/\ry'=ry} (1), (2)
- (0) p->q:v{rx'=v/\ry'=ry} (1), (3)

Checking Symbolic Send Coherence for participant p thus amounts to checking that the following set of muCLP formulae are all invalid: 
- exists (rx1:int) (ry1:int) (rx1':int) (ry1':int) (rx2:int) (ry2:int) (rx2':int) (ry2':int) (x1:int). 
	prodreach_p 0 rx1 ry1 0 rx2 ry2 /\ 
	rx1' = x1 /\ ry1' = ry1 /\ 
	unreach_pq 0 rx2 ry2 x1
- exists (rx1:int) (ry1:int) (rx1':int) (ry1':int) (rx2:int) (ry2:int) (rx2':int) (ry2':int) (x1:int).
	prodreach_p 0 rx1 ry1 1 rx2 ry2 /\ 
	rx1' = x1 /\ ry1' = ry1 /\ 
	unreach_pq 1 rx2 ry2 x1
- exists (rx1:int) (ry1:int) (rx1':int) (ry1':int) (rx2:int) (ry2:int) (rx2':int) (ry2':int) (x1:int).
	prodreach_p 0 rx1 ry1 2 rx2 ry2 /\ 
	rx1' = x1 /\ ry1' = ry1 /\ 
	unreach_pq 2 rx2 ry2 x1
- exists (rx1:int) (ry1:int) (rx1':int) (ry1':int) (rx2:int) (ry2:int) (rx2':int) (ry2':int) (x1:int).
	prodreach_p 0 rx1 ry1 3 rx2 ry2 /\ 
	rx1' = x1 /\ ry1' = ry1 /\ 
	unreach_pq 3 rx2 ry2 x1

And indeed all are invalid! 
These queries correspond to the following files in this directory: 
p_scc_01_0.hes 
p_scc_01_1.hes
p_scc_01_2.hes
p_scc_01_3.hes 

Combining them together into a single query by adding a conjunct to the query that enumerates the case analysis also returns invalid as expected:
p_scc.hes 

Symbolic No Mixed Choice for participant p quantifies over all transitions in S1 in which p is the sender, and over all transitions in S2 in which p is the receiver.
Thus, Symbolic No Mixed Choice for p for this protocol enumerates the following pairs of transitions: 
- (0) p->q:v{rx'=v/\ry'=ry} (1), (2) r->p:v{v>rx/\rx'=rx/\ry'=ry} (3)

Checking Symbolic No Mixed Choice for participant p thus amounts to checking that the following muCLP formula is invalid: 
- exists (rx1:int) (ry1:int) (rx1':int) (ry1':int) (rx2:int) (ry2:int) (rx2':int) (ry2':int) (x1:int) (x2:int).
	prodreach_p 0 rx1 ry1 2 rx2 ry2 /\ 
	rx1' = x1 /\ ry1' = ry1 /\ 
	x2 > rx2 /\ rx2' = rx2 /\ ry2' = ry2

And indeed it is invalid! 
This query corresponds to the following file in the directory: 
p_nmc.hes 

Symbolic Receive Coherence for participant p quantifies over all transitions in S1 and S2 in which p is the receiver with different senders. 
Thus, Symbolic Receive Coherence for p for this protocol enumerates no transitions. 