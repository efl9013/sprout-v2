/* 
Send Validity violating finite protocol: 
States: {0,1,2,3,4}
Registers: {}
Initial register values: N/A

   (0) p->q:v{v=1} (1)
   (0) p->q:v{v=2} (3)
   (1) r->s:v{v=1} (2)
   (3) r->s:v{v=2} (4)

*/
 
/* Symbolic Send Coherence for participant r for this protocol enumerates the following pairs of states and transitions: 
- (1) r->s:v{v=1} (2), (0-4)
- (3) r->s:v{v=2} (4), (0-4)
*/ 

/* The following is the negation of SSC, because apparently the tool cannot handle implies false */ 

/* Expected result: valid */ 
/* Result: valid! */ 

exists (s1:int) (s1':int) (x1:int) (s2:int). 
(((s1=1 /\ s1'=2 /\ 0<=s2 /\ s2<=4)
\/ (s1=3 /\ s1'=4 /\ 0<=s2 /\ s2<=4))
/\
(prodreach_r s1 s2)
/\ 
true
/\
(unreach_rs s2 x1))
s.t. 

/* Defining prodreach_r */ 
prodreach_r (s1:int) (s2:int): bool =mu 
/* First disjunct: base case */ 
(s1 = 0 /\ s2 = 0)
\/ 
/* Second disjuncts: both copies take a step */ 
/* Enumerating pairs of states where both copies can take a simultaneous step: */ 
/*    (1) r->s:v{v=1} (2)
      (1) r->s:v{v=1} (2) */
(s1 = 2 /\ s2 = 2 /\ 
(exists (x1:int) (x2:int). prodreach_r 1 1
/\ 
x1 = 1 
/\ 
x2 = 1 
/\ 
x1 = x2)) 
\/      
/*    (1) r->s:v{v=1} (2)
      (3) r->s:v{v=2} (4) */ 
(s1 = 2 /\ s2 = 4 
/\ 
(exists (x1:int) (x2:int). prodreach_r 1 3
/\ 
x1 = 1 
/\ 
x2 = 2 
/\ 
x1 = x2))
\/ 
/*    (3) r->s:v{v=2} (4)
      (3) r->s:v{v=2} (4) */ 
(s1 = 4 /\ s2 = 4 
/\ 
(exists (x1:int) (x2:int). prodreach_r 1 3
/\ 
x1 = 2 
/\ 
x2 = 2 
/\ 
x1 = x2))
\/
/* Third disjuncts: first copy takes an epsilon step */ 
/* Enumerating states where the first copy takes an epsilon step */ 
/*   (0) p->q:v{v=1} (1) */
(s1 = 1 
/\ 
(exists (x1:int). prodreach_r 0 s2
/\ 
x1 = 1)) 
\/ 
/*   (0) p->q:v{v=2} (3) */ 
(s1 = 3
/\ 
(exists (x1:int). prodreach_r 0 s2
/\ 
x1 = 2))
\/
/* Fourth disjuncts: second copy takes an epsilon step */ 
/* Enumerating states where the second copy takes an epsilon step */ 
/*   (0) p->q:v{v=1} (1) */
(s2 = 1 
/\ 
(exists (x2:int). prodreach_r s1 0
/\ 
x2 = 1)) 
\/ 
/*   (0) p->q:v{v=2} (3) */ 
(s2 = 3
/\ 
(exists (x2:int). prodreach_r s2 0
/\ 
x2 = 2));

/* Defining unreach_rs */
unreach_rs (s:int) (x:int): bool =nu
/* Outermost case split on s */ 
(s = 0
/\ 
(forall (v:int). v = 1 => unreach_rs 1 x)
/\
(forall (v:int). v = 2 => unreach_rs 3 x))
\/ 
(s = 1
/\
(x = 1 => false))
\/ 
(s = 2)
\/ 
(s = 3 
/\
(x = 2 => false))
\/ 
(s = 4);









