/* 
Modified (non-implementable) protocol from Figure 11: 
States: {0,1,2,3}
Registers: {rx,ry}
Initial register values: rx=0, ry=0

Conventions: 
- Communication variable is always v 
- Register preservation is included explicitly 
   (0) p->q:v{rx'=v/\ry'=ry} (1)
   (1) q->r:v{ry'=v/\v>rx/\rx'=rx} (2)
   (2) r->p:v{v>ry/\rx'=rx/\ry'=ry} (3)
*/
 
/* Symbolic Send Coherence for participant r for this protocol enumerates the following pairs of states and transitions: 
- (2) r->p:v{v>ry/\rx'=rx/\ry'=ry} (3), (0)
- (2) r->p:v{v>ry/\rx'=rx/\ry'=ry} (3), (1)
- (2) r->p:v{v>ry/\rx'=rx/\ry'=ry} (3), (2)
- (2) r->p:v{v>ry/\rx'=rx/\ry'=ry} (3), (3)
*/ 

/* The following is the negation of SSC, because apparently the tool cannot handle implies false */ 

/* Expected result: valid */ 
/* Result: invalid */ 

exists (s1:int) (s1':int) (x1:int) (rx_1:int) (ry_1:int) (rx_1':int) (ry_1':int) (s2:int) (rx_2:int) (ry_2:int). 
(((s1=2 /\ s1'=3 /\ s2=0)
\/ (s1=2 /\ s1'=3 /\ s2=1)
\/ (s1=2 /\ s1'=3 /\ s2=2)
\/ (s1=2 /\ s1'=3 /\ s2=3))
/\
(x1>ry_1 /\ rx_1'=rx_1 /\ ry_1'=ry_1)
/\
(unreach_rp s2 rx_2 ry_2 x1))
s.t. 

/* Defining unreach_rp */
/* Note that because this definition is a series of conjunctions, 
   the case analysis on s must occur outside the conjunctions! */ 
unreach_rp (s:int) (rx:int) (ry:int) (x:int): bool =nu
(s = 0
/\
(forall (v:int) (rx':int) (ry':int). rx'=v\/ry=ry => unreach_rp 1 rx' ry' x))
\/
(s = 1)
\/ 
(s = 2
/\
(forall (rx':int) (ry':int). x>ry/\rx'=rx/\ry'=ry => false))
\/
(s = 3);
/* First conjuncts: r->p transition, but predicate disabled */ 
/*    (2) r->p:v{v>ry/\rx'=rx/\ry'=ry} (3) */ 
/* Second conjuncts: epsilon transition */ 
/*    (0) p->q:v{rx'=v/\ry'=ry} (1) */ 