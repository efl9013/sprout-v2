/* 
Protocol from Figure 11: 
States: {0,1,2,3}
Registers: {rx,ry}
Initial register values: rx=0, ry=0

Conventions: 
- Communication variable is always v 
- Register preservation is included explicitly 
   (0) p->q:v{rx'=v/\ry'=ry}. 
   (1) q->r:v{ry'=v/\v>rx/\rx'=rx}. 
   (2) r->p:v{v>rx/\ry'=ry}. 
   (3) 
*/
 
/* Symbolic Send Coherence for participant p for this protocol enumerates the following pairs of states and transitions: 
- (0) p->q:v{rx'=v/\ry'=ry} (1), (0)
- (0) p->q:v{rx'=v/\ry'=ry} (1), (1)
- (0) p->q:v{rx'=v/\ry'=ry} (1), (2)
- (0) p->q:v{rx'=v/\ry'=ry} (1), (3)
*/ 

/* The following is the negation of SSC, because apparently the tool cannot handle implies false */ 

exists (s1:int) (s1':int) (r1x:int) (r1y:int) (r1x':int) (r1y':int) (s2:int) (s2':int) (r2x:int) (r2y:int) (r2x':int) (r2y':int) (x:int). 
(((s1=0 /\ s1'=1 /\ s2=0)
\/ (s1=0 /\ s1'=1 /\ s2=1)
\/ (s1=0 /\ s1'=1 /\ s2=2)
\/ (s1=0 /\ s1'=1 /\ s2=3))
/\
(prodreach_p s1 r1x r1y s2 r2x r2y)
/\ 
(r1x'=x /\ r1y'=r1y)
/\
(unreach_pq s2 r2x r2y x)) 
s.t. 
/* Defining prodreach_p */ 
prodreach_p (s1:int) (r1x:int) (r1y:int) (s2:int) (r2x:int) (r2y:int): bool =mu 
/* First disjunct: base case */ 
(s1 = 0 /\ s2 = 0 /\ r1x = 0 /\ r1y = 0 /\ r2x = 0 /\ r2y = 0)
\/ 
/* Second disjuncts: both copies take a step */ 
/* Enumerating pairs of states where both copies can take a simultaneous step */ 
(s1 = 1 /\ s2 = 1 /\ (exists (x1:int) (x2:int) (r1x_pre:int) (r1y_pre:int) (r2x_pre:int) (r2y_pre:int). 
prodreach_p 0 r1x_pre r1y_pre 0 r2x_pre r2y_pre /\ r1x = x1 /\ r1y = r1y_pre /\ r2x = x2 /\ r2y = r2y_pre /\ x1 = x2))
\/ 
(s1 = 3 /\ s2 = 3 /\ (exists (x1:int) (x2:int) (r1x_pre:int) (r1y_pre:int) (r2x_pre:int) (r2y_pre:int). 
prodreach_p 2 r1x_pre r1y_pre 2 r2x_pre r2y_pre /\ x1 > r1x /\ r1y = r1y_pre /\ x2 > r2x_pre /\ r2y = r2y_pre))
\/ 
/* Third disjuncts: first copy takes a step */ 
/* Enumerating states where the first copy takes an epsilon step */ 
(s1 = 2 /\ (exists (x1:int) (r1x_pre:int) (r1y_pre:int). prodreach_p 1 r1x_pre r1y_pre s2 r2x r2y /\ r1y=x1/\x1>r1x/\r1x=r1x_pre))
\/ 
/* Fourth disjuncts: second copy takes a step */ 
(s2 = 2 /\ (exists (x2:int) (r2x_pre:int) (r2y_pre:int). prodreach_p s1 r1x r1y 1 r2x_pre r2y_pre /\ r2y=x2/\x2>r2x_pre/\r2x=r2x_pre));

/* Defining unreach_pq */
unreach_pq (s:int) (rx:int) (ry:int) (x:int): bool =nu
/* First conjuncts: p->q transition, but predicate disabled */ 
(s = 0 /\ (forall (rx':int) (ry':int). rx'=x/\ry'=ry => false))
/\ 
/* Second conjuncts: epsilon transition */ 
(s = 1 /\ (forall (y:int) (rx':int) (ry':int). ry'=y/\y>rx/\rx'=rx => unreach_pq 2 rx' ry' x))
/\
(s = 2 /\ (forall (y:int) (rx':int) (ry':int). y>rx/\ry'=ry => unreach_pq 3 rx' ry' x));