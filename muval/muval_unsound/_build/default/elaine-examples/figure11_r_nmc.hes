/* 
Protocol from Figure 11: 
States: {0,1,2,3}
Registers: {rx,ry}
Initial register values: rx=0, ry=0

Conventions: 
- Communication variable is always v 
- Register preservation is included explicitly 
   (0) p->q:v{rx'=v/\ry'=ry}. 
   (1) q->r:v{ry'=v/\v>rx/\rx'=rx}. 
   (2) r->p:v{v>ry/\rx'=rx/\ry'=ry}. 
   (3) 
*/
 
/* Symbolic No Mixed Choice for participant r for this protocol enumerates the following pairs of transitions: 
- (1) q->r:v{ry'=v/\v>rx/\rx'=rx} (2), (2) r->p:v{v>ry/\rx'=rx/\ry'=ry} (3)
*/ 

/* The following is the negation of SNMC, because apparently the tool cannot handle implies false */ 

/* Expected result: invalid */ 
/* Result: invalid */ 

exists (s1:int) (s1':int) (r1x:int) (r1y:int) (r1x':int) (r1y':int) (s2:int) (s2':int) (r2x:int) (r2y:int) (r2x':int) (r2y':int) (x1:int) (x2:int). 
((s1=1 /\ s1'=2 /\ s2=2 /\ s2'=3)
/\
(prodreach_r s1 r1x r1y s2 r2x r2y)
/\ 
(r1y'=x1/\x1>r1x/\r1x'=r1x) 
/\
(r2y'=x2/\x2>r2x/\r2x'=r2x))
s.t. 
/* Defining prodreach_r */ 
prodreach_r (s1:int) (r1x:int) (r1y:int) (s2:int) (r2x:int) (r2y:int): bool =mu 
/* First disjunct: base case */ 
(s1 = 0 /\ s2 = 0 /\ r1x = 0 /\ r1y = 0 /\ r2x = 0 /\ r2y = 0)
\/ 
/* Second disjuncts: both copies take a step */ 
/* Enumerating pairs of states where both copies can take a simultaneous step:
- (1) q->r:v{ry'=v/\v>rx/\rx'=rx} (2)
- (2) r->p:v{v>ry/\rx'=rx/\ry'=ry} (3) */ 
(s1 = 2 /\ s2 = 2 /\ (exists (x1:int) (x2:int) (r1x_pre:int) (r1y_pre:int) (r2x_pre:int) (r2y_pre:int). 
prodreach_r 1 r1x_pre r1y_pre 1 r2x_pre r2y_pre /\ r1y = x1 /\ x1 > r1x_pre /\ r1x = r1x_pre /\ r2y = x2 /\ x2 > r2x_pre /\ r2x = r2x_pre /\ x1 = x2))
\/ 
(s1 = 3 /\ s2 = 3 /\ (exists (x1:int) (x2:int) (r1x_pre:int) (r1y_pre:int) (r2x_pre:int) (r2y_pre:int). 
prodreach_r 2 r1x_pre r1y_pre 2 r2x_pre r2y_pre /\ x1 > r1x /\ r1y = r1y_pre /\ x2 > r2x_pre /\ r2y = r2y_pre /\ x1 = x2))
\/ 
/* Third disjuncts: first copy takes an epsilon step */ 
/* Enumerating states where the first copy takes an epsilon step */ 
(s1 = 2 /\ (exists (x1:int) (r1x_pre:int) (r1y_pre:int). prodreach_r 1 r1x_pre r1y_pre s2 r2x r2y /\ r1y=x1/\x1>r1x/\r1x=r1x_pre))
\/ 
/* Fourth disjuncts: second copy takes a step */ 
(s2 = 2 /\ (exists (x2:int) (r2x_pre:int) (r2y_pre:int). prodreach_r s1 r1x r1y 1 r2x_pre r2y_pre /\ r2y=x2/\x2>r2x_pre/\r2x=r2x_pre));